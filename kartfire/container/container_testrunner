#!/usr/bin/env python3
#	kartfire - Test framework to consistently run submission files
#	Copyright (C) 2023-2025 Johannes Bauer
#
#	This file is part of kartfire.
#
#	kartfire is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; this program is ONLY licensed under
#	version 3 of the License, later versions are explicitly excluded.
#
#	kartfire is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with kartfire; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#	Johannes Bauer <JohannesBauer@gmx.de>

import os
import json
import sys
import subprocess
import argparse
import contextlib

class ContainerRunFailedException(Exception):
	def __init__(self, msg: str, code: str, cmd: list[str], execution_hint: str):
		super().__init__(msg)
		self._code = code
		self._cmd = cmd
		self._execution_hint = execution_hint

	def to_dict(self):
		result = {
			"text": str(self),
			"code": self._code,
			"cmd": self._cmd,
			"execution_hint": self._execution_hint,
		}
		if self.__cause__ is not None:
			result.update({
				"cause": {
					"type": self.__cause__.__class__.__name__,
					"text": str(self.__cause__),
				},
			})
		return result

class ContainerTestRunner():
	def __init__(self, args):
		self._args = args

		with open(self._args.configuration) as f:
			self._config = json.load(f)

	@property
	def verbose(self):
		return max(self._config["verbose"], self._args.verbose)

	def _execute(self, cmd: list[str], timeout: float, execution_hint: str):
		try:
			exec_result = subprocess.run(cmd, timeout = timeout)
		except subprocess.TimeoutExpired as e:
			raise ContainerRunFailedException(f"{execution_hint} terminated with timeout ({timeout:.0f} seconds)", code = "exec_timeout", cmd = cmd, execution_hint = execution_hint) from e
		except PermissionError as e:
			raise ContainerRunFailedException(f"{execution_hint} terminated with {e.__class__.__name__}", code = "exec_permission", cmd = cmd, execution_hint = execution_hint) from e
		except Exception as e:
			raise ContainerRunFailedException(f"{execution_hint} terminated with {e.__class__.__name__}", code = "exec_other", cmd = cmd, execution_hint = execution_hint) from e

		if exec_result.returncode == -9:
			raise ContainerRunFailedException(f"{execution_hint} terminated with out-of-memory error", code = "exec_oom", cmd = cmd, execution_hint = execution_hint)
		elif exec_result.returncode != 0:
			raise ContainerRunFailedException(f"{execution_hint} terminated with return code {exec_result.returncode}", code = "exec_failed", cmd = cmd, execution_hint = execution_hint)

	def _unpack(self):
		with contextlib.suppress(FileExistsError):
			os.makedirs(self._config["container_dut_dir"])
		self._execute([ "tar", "-x", "-C", self._config["container_dut_dir"], "-f", self._config["container_submission_tar_file"] ], timeout = 10, execution_hint = "untar")

	def _setup(self):
		setup_executable = f"{self._config['container_dut_dir']}/{self._config['setup_name']}"
		if os.path.exists(setup_executable):
			self._execute([ setup_executable ], timeout = self._config["max_setup_time_secs"], execution_hint = "build")

	def _run(self):
		solution_executable = f"{self._config['container_dut_dir']}/{self._config['solution_name']}"
		self._execute([ solution_executable, self._config["container_testcase_file"] ], timeout = self._config["max_runtime_secs"], execution_hint = "test")

	def run(self):
		try:
			self._unpack()
			self._setup()
			self._run()
		except ContainerRunFailedException as e:
			print()
			print(json.dumps({
				"_": "9d83e7a5-bb94-40a1-9f59-a6586d2c3c94",
				"exception": e.to_dict(),
			}))
			sys.exit(1)

parser = argparse.ArgumentParser(description = "Run testcases inside a kartfire container.")
parser.add_argument("-c", "--configuration", metavar = "filename", default = "/meta.json", help = "Specifies configuretion file to use. Defaults to %(default)s.")
parser.add_argument("-v", "--verbose", action = "count", default = 0, help = "Increases verbosity. Can be specified multiple times to increase.")
args = parser.parse_args(sys.argv[1:])

ctr = ContainerTestRunner(args)
ctr.run()
