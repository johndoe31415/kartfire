#!/usr/bin/env python3
#	kartfire - Test framework to consistently run submission files
#	Copyright (C) 2023-2025 Johannes Bauer
#
#	This file is part of kartfire.
#
#	kartfire is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; this program is ONLY licensed under
#	version 3 of the License, later versions are explicitly excluded.
#
#	kartfire is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with kartfire; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#	Johannes Bauer <JohannesBauer@gmx.de>

import os
import json
import sys
import subprocess
import argparse
import contextlib

class ContainerRunFailedException(Exception):
	def __init__(self, code: str, msg: str):
		super().__init__(self, msg)
		self._code = code

	@property
	def code(self):
		return self._code

class ContainerTestRunner():
	def __init__(self, args):
		self._args = args
		with open(self._args.configuration) as f:
			self._config = json.load(f)

	@property
	def verbose(self):
		return max(self._config["verbose"], self._args.verbose)

	def _execute(self, cmd: list[str], timeout: float):
		stderr = subprocess.DEVNULL if (self.verbose < 2) else None
		try:
			exec_result = subprocess.run(cmd, timeout = timeout, stderr = stderr)
			if exec_result.returncode == -9:
				raise ContainerRunFailedException("exec_oom", f"{cmd}: Process execution terminated with out-of-memory error")
			elif exec_result.returncode != 0:
				raise ContainerRunFailedException("exec_failed", f"{cmd}: Process execution terminated with return code {exec_result.returncode}")
		except subprocess.TimeoutExpired as e:
			raise ContainerRunFailedException("exec_timeout", f"{cmd}: Process execution terminated with timeout ({timeout:.0f} seconds)") from e
		except PermissionError as e:
			raise ContainerRunFailedException("exec_permission", f"{cmd}: Process execution terminated with {e.__class__.__name__}. Check that the target is executable: {str(e)}") from e
		except Exception as e:
			raise ContainerRunFailedException("exec_oserror", f"{cmd}: Process execution terminated with {e.__class__.__name__}: {str(e)}") from e

	def _unpack(self):
		with contextlib.suppress(FileExistsError):
			os.makedirs(self._config["container_dut_dir"])
		self._execute([ "tar", "-x", "-C", self._config["container_dut_dir"], "-f", self._config["container_submission_tar_file"] ], timeout = 10)

	def _setup(self):
		setup_executable = f"{self._config['container_dut_dir']}/{self._config['setup_name']}"
		if os.path.exists(setup_executable):
			self._execute([ setup_executable ], timeout = self._config["max_setup_time_secs"])

	def _run(self):
		solution_executable = f"{self._config['container_dut_dir']}/{self._config['solution_name']}"
		self._execute([ solution_executable, self._config["container_testcase_file"] ], timeout = self._config["max_runtime_secs"])

	def run(self):
		try:
			self._unpack()
			self._setup()
			self._run()
		except ContainerRunFailedException as e:
			print()
			print(json.dumps({
				"_": "9d83e7a5-bb94-40a1-9f59-a6586d2c3c94",
				"code": e.code,
				"exception": str(e),
			}))

parser = argparse.ArgumentParser(description = "Run testcases inside a kartfire container.")
parser.add_argument("-c", "--configuration", metavar = "filename", default = "/meta.json", help = "Specifies configuretion file to use. Defaults to %(default)s.")
parser.add_argument("-v", "--verbose", action = "count", default = 0, help = "Increases verbosity. Can be specified multiple times to increase.")
args = parser.parse_args(sys.argv[1:])

ctr = ContainerTestRunner(args)
ctr.run()
