#!/usr/bin/env python3
#	kartfire - Test framework to consistently run submission files
#	Copyright (C) 2023-2024 Johannes Bauer
#
#	This file is part of kartfire.
#
#	kartfire is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; this program is ONLY licensed under
#	version 3 of the License, later versions are explicitly excluded.
#
#	kartfire is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with kartfire; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#	Johannes Bauer <JohannesBauer@gmx.de>

import os
import base64
import json
import sys
import time
import subprocess
import contextlib
import tempfile
import stat
import collections

if len(sys.argv) < 2:
	print(f"{sys.argv[0]}: No argument given.", file = sys.stderr)
	sys.exit(1)

class ContainerTestrunner():
	def __init__(self, config_filename: str):
		with open(config_filename) as f:
			self._config = json.load(f)
		with contextlib.suppress(FileExistsError):
			os.makedirs(self.meta["local_dut_dir"])
		self._tc_results = { }

	def logmsg(self, msg: str):
		if self.meta.get("debug"):
			print(msg, file = sys.stderr)

	@property
	def meta(self) -> dict:
		return self._config["meta"]

	@property
	def max_testbatch_size(self) -> int:
		return self.meta.get("max_testbatch_size", 1)

	@property
	def testcases(self) -> list[dict]:
		return self._config["testcases"]

	@property
	def testcase_count(self):
		return len(self.testcases)

	def _exec(self, cmd: list[str], timeout_secs: float):
		t0 = time.time()
		had_timeout = False
		exception_msg = None
		stdout = bytes()
		stderr = bytes()
		returncode = None
		try:
			result = subprocess.run(cmd, stdout = subprocess.PIPE, stderr = subprocess.PIPE, timeout = timeout_secs)
			stdout = result.stdout
			stderr = result.stderr
			returncode = result.returncode
			if returncode == -9:
				exception_msg = "Out of memory, process terminated."
		except subprocess.TimeoutExpired as e:
			had_timeout = True
			exception_msg = f"{e.__class__.__name__} when trying execution: {str(e)}"
		except PermissionError as e:
			perms = stat.S_IMODE(os.stat(cmd[0]).st_mode)
			missing_exec = (perms & 0o111) == 0
			exception_msg = f"{e.__class__.__name__} when trying execution of {cmd[0]} (permissions {perms:#o}{' - missing execution bit!' if missing_exec else ''}): {str(e)}"
		except OSError as e:
			exception_msg = f"{e.__class__.__name__} when trying execution: {str(e)}"
		runtime_secs = time.time() - t0

		return {
			"stdout": stdout[-self.meta["limit_stdout_bytes"] : ],
			"stderr": stderr[-self.meta["limit_stdout_bytes"] : ],
			"stdout_length": len(stdout),
			"stderr_length": len(stderr),
			"returncode": returncode,
			"runtime_secs": runtime_secs,
			"timeout": had_timeout,
			"exception_msg": exception_msg,
		}

	def _unpack_files(self):
		if "local_testcase_tar_file" in self.meta:
			subprocess.check_call([ "tar", "-x", "-C", self.meta["local_dut_dir"], "-f", self.meta["local_testcase_tar_file"] ])
		else:
			self.logmsg("No key 'local_testcase_tar_file' given, expecting DUT directory to already exist.")

	def _run_setup(self):
		setup_exec = f"{self.meta['local_dut_dir']}/{self.meta['setup_name']}"
		if os.path.exists(setup_exec):
			return self._exec([ setup_exec ], timeout = self.meta["max_setup_time_secs"])

	def _run_testbatch(self, testbatch: list[dict], subtract_time_secs: float = 0):
		with open(self.meta["local_testcase_filename"], "w") as f:
			local_json_content = {
				"testcases": { testcase["name"]: testcase["testcase_data"] for testcase in testbatch },
			}
			json.dump(local_json_content, f)
		solution_exec = f"{self.meta['local_dut_dir']}/{self.meta['solution_name']}"
		total_runtime_allowance_secs = sum(testcase["runtime_allowance_secs"] for testcase in testbatch) - subtract_time_secs
		if total_runtime_allowance_secs > 0:
			testbatch_results = self._exec([ solution_exec, self.meta["local_testcase_filename"] ], timeout_secs = total_runtime_allowance_secs)
			return {
				"testcases": [ testcase["name"] for testcase in testbatch ],
				"results": testbatch_results,
			}
		else:
			return None

	def _get_initial_testbatches(self):
		"""Split testbatches into groups of maximum size initially."""
		for i in range(0, self.testcase_count, self.max_testbatch_size):
			yield self.testcases[i : i + self.max_testbatch_size]

	def _recursive_run_testbatch(self, testbatch: list[dict], subtract_time_secs: float = 0):
		result = [ ]
		self.logmsg(f"Running testbatch of {len(testbatch)} testcases, subtracting {subtract_time_secs:.3f} secs from time contingent.")

		t0 = time.time()
		batch_result = self._run_testbatch(testbatch, subtract_time_secs = subtract_time_secs)
		t1 = time.time()
		if batch_result is not None:
			# Was the run successful or was it a single case?
			if (batch_result["results"]["returncode"] == 0) or (len(testbatch) < 2):
				# Record results
				result.append(batch_result)
			else:
				# Bisect array, subtracting previously taken time from contingent
				taken = t1 - t0
				half = len(testbatch) // 2
				left = testbatch[ : half]
				right = testbatch[half : ]
				self.logmsg(f"Bisecting previous batch of {len(testbatch)} testcases, subtracting {taken:.3f} additional secs from time contingent, splitting into {len(left)} and {len(right)} testcases.")
				result += self._recursive_run_testbatch(left, subtract_time_secs + taken / 2)
				result += self._recursive_run_testbatch(right, subtract_time_secs + taken / 2)
		return result

	def run(self):
		t0 = time.time()
		result = {
			"setup": None,
			"testcase_results": [ ],
		}
		self._unpack_files()
		result["setup"] = self._run_setup()
		for testbatch in self._get_initial_testbatches():
			result["testcase_results"] += self._recursive_run_testbatch(testbatch)
		result["runtime_secs"] = time.time() - t0
		return result

def serializer(obj):
	if isinstance(obj, bytes):
		return base64.b64encode(obj).decode("ascii")
	elif isinstance(obj, enum.Enum):
		return obj.value
	else:
		raise TypeError(obj)

config_filename = sys.argv[1]
ctr = ContainerTestrunner(config_filename)
result = ctr.run()
print(json.dumps(result, default = serializer))
