#!/usr/bin/env python3
#	kartfire - Test framework to consistently run submission files
#	Copyright (C) 2023-2025 Johannes Bauer
#
#	This file is part of kartfire.
#
#	kartfire is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; this program is ONLY licensed under
#	version 3 of the License, later versions are explicitly excluded.
#
#	kartfire is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with kartfire; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#	Johannes Bauer <JohannesBauer@gmx.de>

import os
import json
import sys
import pwd
import time
import subprocess
import argparse

class ContainerRunFailedException(Exception):
	def __init__(self, msg: str, code: str, cmd: list[str], execution_hint: str):
		super().__init__(msg)
		self._code = code
		self._cmd = cmd
		self._execution_hint = execution_hint

	def to_dict(self):
		result = {
			"text": str(self),
			"code": self._code,
			"cmd": self._cmd,
			"execution_hint": self._execution_hint,
		}
		if self.__cause__ is not None:
			result.update({
				"cause": {
					"type": self.__cause__.__class__.__name__,
					"text": str(self.__cause__),
				},
			})
		return result

class ContainerTestRunner():
	def __init__(self, args):
		self._args = args

		with open(self._args.configuration) as f:
			self._config = json.load(f)

	@property
	def verbose(self):
		return max(self._config["verbose"], self._args.verbose)

	@property
	def unprivileged_user(self):
		user_info = pwd.getpwnam(self._config["unprivileged_user"])
		(uid, gid) = (user_info.pw_uid, user_info.pw_gid)
		return (uid, gid)

	def _drop_privileges(self):
		(uid, gid) = self.unprivileged_user
		os.setgroups([ ])
		os.setresgid(gid, gid, gid)
		os.setresuid(uid, uid, uid)

	def _execute(self, cmd: list[str], execution_hint: str, timeout: float | None = None):
		try:
			t0 = time.monotonic()
			exec_result = subprocess.run(cmd, timeout = timeout, preexec_fn = self._drop_privileges)
			t1 = time.monotonic()
			self._emit_privileged_msg("time", {
				"time": t1 - t0,
				"target": execution_hint,
			})
		except subprocess.TimeoutExpired as e:
			raise ContainerRunFailedException(f"{execution_hint} terminated with timeout ({timeout:.0f} seconds)", code = "exec_timeout", cmd = cmd, execution_hint = execution_hint) from e
		except PermissionError as e:
			raise ContainerRunFailedException(f"{execution_hint} terminated with {e.__class__.__name__}", code = "exec_permission", cmd = cmd, execution_hint = execution_hint) from e
		except Exception as e:
			raise ContainerRunFailedException(f"{execution_hint} terminated with {e.__class__.__name__}", code = "exec_other", cmd = cmd, execution_hint = execution_hint) from e

		if exec_result.returncode == -9:
			raise ContainerRunFailedException(f"{execution_hint} terminated with out-of-memory error", code = "exec_oom", cmd = cmd, execution_hint = execution_hint)
		elif exec_result.returncode != 0:
			raise ContainerRunFailedException(f"{execution_hint} terminated with return code {exec_result.returncode}", code = "exec_failed", cmd = cmd, execution_hint = execution_hint)

	def _unpack(self):
		self._execute([ "tar", "-x", "-C", self._config["container_dut_dir"], "-f", self._config["container_submission_tar_file"] ], execution_hint = "untar")

	def _build(self):
		build_executable = f"{self._config['container_dut_dir']}/{self._config['build_name']}"
		if os.path.exists(build_executable):
			self._execute([ build_executable ], execution_hint = "build")

	def _run(self):
		# Execute newline so that in interactive run, first testcase does not
		# get mangled with prompt and becomes unparsable/no_answer
		print()
		solution_executable = f"{self._config['container_dut_dir']}/{self._config['solution_name']}"
		self._execute([ solution_executable, self._config["container_testcase_file"] ], execution_hint = "test")

	def _emit_privileged_msg(self, msg_type: str, msg: dict):
		sys.stdout.flush()
		print()
		print(json.dumps({
			"kartfire": self._config["testrunner_key"],
			"type": msg_type,
			"msg": msg,
		}))
		sys.stdout.flush()

	def _fix_privileges(self):
		os.chown(self._args.configuration, 0, 0)
		os.chmod(self._args.configuration, 0o600)
		if self._args.execute_build:
			(uid, gid) = self.unprivileged_user
			os.makedirs(self._config["container_dut_dir"], exist_ok = True)
			os.chown(self._config["container_dut_dir"], uid, gid)
			os.chown(self._config["container_submission_tar_file"], 0, 0)
			os.chmod(self._config["container_submission_tar_file"], 0o644)
		if self._args.execute_run:
			os.chown(self._config["container_testcase_file"], 0, 0)
			os.chmod(self._config["container_testcase_file"], 0o644)

	def run(self):
		if (not self._args.execute_build) and (not self._args.execute_run):
			print("Nothing to do, neither build nor run parameter given on command line.")
			sys.exit(1)

		try:
			self._fix_privileges()
			if self._args.execute_build:
				self._unpack()
				self._build()
			if self._args.execute_run:
				self._run()
		except ContainerRunFailedException as e:
			self._emit_privileged_msg("exception", {
				"exception": e.to_dict(),
			})
			sys.exit(1)

parser = argparse.ArgumentParser(description = "Run build step or testcases inside a kartfire container.")
parser.add_argument("-c", "--configuration", metavar = "filename", default = "/meta.json", help = "Specifies configuration file to use. Defaults to %(default)s.")
parser.add_argument("-b", "--execute-build", action = "store_true", help = "Execute the build step.")
parser.add_argument("-r", "--execute-run", action = "store_true", help = "Execute the run step.")
parser.add_argument("-v", "--verbose", action = "count", default = 0, help = "Increases verbosity. Can be specified multiple times to increase.")
args = parser.parse_args(sys.argv[1:])

ctr = ContainerTestRunner(args)
ctr.run()
